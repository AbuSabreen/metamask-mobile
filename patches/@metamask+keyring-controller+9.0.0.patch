diff --git a/node_modules/@metamask/keyring-controller/dist/KeyringController.js b/node_modules/@metamask/keyring-controller/dist/KeyringController.js
index da9523a..c53f501 100644
--- a/node_modules/@metamask/keyring-controller/dist/KeyringController.js
+++ b/node_modules/@metamask/keyring-controller/dist/KeyringController.js
@@ -757,6 +757,39 @@ class KeyringController extends base_controller_1.BaseControllerV2 {
             }
         });
     }
+
+  /**
+   * This Patch is generated to support the multiple accounts support for ledger devices,
+   * The reason to create this is to access the #keyring private method is not possible from the outside.
+   * To add multiple accounts support for ledger Hardware wallet
+   *
+   * @param index - Index of the account to unlock
+   * @param keyring - Keyring instance to unlock
+   * @return {*} - Promise resolving to the current state
+   */
+  unlockLedgerWalletAccount(index, keyring) {
+    return __awaiter(this, void 0, void 0, function* () {
+      keyring.setAccountToUnlock(index);
+      const oldAccounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
+      // QRKeyring is not yet compatible with Keyring from
+      // @metamask/utils, but we can use the `addNewAccount` method
+      // as it internally calls `addAccounts` from on the keyring instance,
+      // which is supported by QRKeyring API.
+      yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").addNewAccount(keyring);
+      const newAccounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
+      this.updateIdentities(newAccounts);
+      newAccounts.forEach((address) => {
+        if (!oldAccounts.includes(address)) {
+          if (this.setAccountLabel) {
+            this.setAccountLabel(address, `Ledger: ${index}`);
+          }
+          this.setSelectedAddress(address);
+        }
+      });
+      yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").persistAllKeyrings();
+    });
+  }
+
     unlockQRHardwareWalletAccount(index) {
         return __awaiter(this, void 0, void 0, function* () {
             const keyring = yield this.getOrAddQRKeyring();
@@ -785,15 +818,25 @@ class KeyringController extends base_controller_1.BaseControllerV2 {
             return (yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getKeyringForAccount(account)).type;
         });
     }
+    /**
+     * ============================== PATCH INFORMATION ==============================
+     * This patch addresses an issue regarding the forget device functionality. It
+     * improves the logic  to correctly remove the QR accounts and update the
+     * identities as needed.
+     *
+     * Solved in https://github.com/MetaMask/core/pull/3641
+     * ===============================================================================
+     */
     forgetQRDevice() {
         return __awaiter(this, void 0, void 0, function* () {
             const keyring = yield this.getOrAddQRKeyring();
+            const allAccounts = (yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts());
             keyring.forgetDevice();
-            const accounts = (yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts());
-            accounts.forEach((account) => {
-                this.setSelectedAddress(account);
-            });
+            const remainingAccounts = (yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts());
+            const removedAccounts = allAccounts.filter((address) => !remainingAccounts.includes(address));
+            this.updateIdentities(remainingAccounts);
             yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").persistAllKeyrings();
+            return { removedAccounts, remainingAccounts };
         });
     }
 }
